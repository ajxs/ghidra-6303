# sleigh specification file for 6303

define endian=little;
define alignment=1;

define space RAM     type=ram_space      size=2  default;
define space register type=register_space size=1;

define register offset=0x00  size=1 [ A B ];
define register offset=0x00  size=2 [ D X];
define register offset=0x20 size=2  [ PC      SP   ];
define register offset=0x20 size=1  [ PCL PCH SH ];
define register offset=0x30 size=1 [ H I N Z V C ];	# status bits

#TOKENS

define token opbyte (8)
   op       = (0,7)
   
   aaa      = (5,7)
   bbb      = (2,4)
   cc       = (0,1)
   
   hhh      = (4,7)
   lo       = (0,3)
;

define token data8 (8)
   imm8		= (0,7)
   rel		= (0,7) signed
;

define token data (16)
	imm16 = (0,15)
;

macro popSR() {
	local ccr = *:1 SP;
        H = ccr[5,1];
	I = ccr[4,1];
	N = ccr[3,1];
	Z = ccr[2,1];
	V = ccr[1,1];
	C = ccr[0,1];
}

macro pushSR() {
	local ccr:1 = 0xff;
	ccr[7,1] = 1;
	ccr[6,1] = 1;
	ccr[5,1] = H;
        ccr[4,1] = I;
	ccr[3,1] = N;
	ccr[2,1] = Z;
	ccr[1,1] = V;
	ccr[0,1] = C;
	*:1 (SP) = ccr;
	SP = SP -1;
}

macro resultFlags(value) {
	Z = (value == 0);
	N = (value s< 0);
}

macro subtraction_flags1(register, operand, result) {
	local complement_register = ~register;
	
	V = ( ((register & ~operand & ~result) | (complement_register & operand & result)) & 0b10000000 ) != 0;
	N = (result s< 0);
	Z = (result == 0);
	C = ( ((complement_register & operand) | (operand & result) | (result & complement_register)) & 0b10000000 ) != 0;
}


################################################################
# Psuedo Instructions
################################################################

define pcodeop readIRQ;

################################################################
REL: reloc		is rel	[ reloc = inst_next + rel; ] { export *:2 reloc; } 

# Immediate
OP1: A "#"imm8    is hhh=8; imm8			{ tmp:1 = imm8; export tmp; }
# Direct
OP1: A imm8       is hhh=9; imm8			{ export *:1 imm8; }
# Indexed
OP1: A imm8,X     is hhh=10 & X; imm8		{ addr:2 = zext(imm8 + X); tmp:2 = *:2 addr; export *:1 tmp; }
# Extended
OP1: A imm16      is hhh=11; imm16	{ export *:1 imm16; }
OP1: B "#"imm8    is hhh=12; imm8	{ tmp:1 = imm8; export tmp; }
# Direct
OP1: B imm8       is hhh=13; imm8	{ export *:1 imm8; }
# Indexed
OP1: B imm8,X     is hhh=14 & X; imm8	{ addr:2 = zext(imm8 + X); tmp:2 = *:2 addr; export *:1 tmp; }
# Extended
OP1: B imm16      is hhh=15; imm16	{ export *:1 imm16; }


OP2: A          is hhh=4 & A            { export A; }
OP2: B          is hhh=5 & B            { export B; }
OP2: imm8,X     is hhh=6 & X; imm8	{ addr:2 = zext(imm8 + X); tmp:2 = *:2 addr; export *:1 tmp; }
# Extended
OP2: imm16      is hhh=7; imm16		{ export *:1 imm16; }


# Absolute
OP2: imm16      is bbb=3; imm16			{ export *:1 imm16; }
# Zero Page Indexed X
OP2: imm8,X     is bbb=5 & X; imm8		{ tmp:2 = zext(imm8 + X); export *:1 tmp; }
# Absolute Indexed X
OP2: imm16,X    is bbb=7 & X; imm16		{ tmp:2 = imm16 + zext(X); export *:1 tmp; }

OP2ST: OP2      is OP2                  { export OP2; }

OP2LD: OP2      is OP2                  { export OP2; }

# operand for X
# Immediate
OP3: "#"imm16    is bbb=2; imm16	{ tmp:2 = imm16; export tmp; }
# Zero Page
OP3: imm8       is bbb=1; imm8			{ export *:2 imm8; }
# Zero Page Indexed X
OP3: imm8,X     is bbb=5 & X; imm8		{ tmp:2 = zext(imm8 + X); export *:2 tmp; }
# Absolute
OP3: imm16      is bbb=3; imm16			{ export *:2 imm16; }

OP3ST: OP3      is OP3                  { export OP3; }

OP3LD: OP3      is OP3                  { export OP3; }

ADDR8:  imm8    is imm8		{ export *:1 imm8; }
ADDR16: imm16   is imm16   	{ export *:1 imm16; }
ADDRI:  imm16   is imm16    { tmp:2 = imm16; export *:2 tmp; }

# Instructions


:ADC OP1     is lo=9 ... & OP1
{
	local op1 = OP1;
	local tmpC = C;
	
	C = carry(A, op1);
	
	A = A + op1 + tmpC;

	resultFlags(A);
	V = C;
}

:AND OP1     is lo=4 ... & OP1
{ 
	A = A & OP1; 
	resultFlags(A);
}

:ASL OP2     is (op=0x84 | op=0x85 | op=0x86 | op=0x87) ... & OP2
{
	local tmp = OP2;
	C = tmp >> 7;
	tmp = tmp << 1;
	OP2 = tmp;
	resultFlags(tmp);	
}

:BCC  REL			is op=0x24; REL
{
	if (C == 0) goto REL;
}

:BCS  REL			is op=0x25; REL
{
	if (C) goto REL;
}

:BEQ  REL			is op=0x27; REL
{
	if (Z) goto REL;
}

:BIT OP1     is lo=5 ... & OP1
{
	local value = A & OP1;
	resultFlags(value);
}

:BMI  REL			is op=0x2B; REL
{
	if (N) goto REL;
}

:BNE  REL			is op=0x26; REL
{
	if (Z == 0) goto REL;
}

:BPL  REL			is op=0x2A; REL
{
	if (N == 0) goto REL;
}

:BVC  REL			is op=0x28; REL
{
	if (V == 0) goto REL;
}

:BVS  REL			is op=0x29; REL
{
	if (V) goto REL;
}

:CLC     is op=0x0C
{
	C = 0;
}

:CLI     is op=0x0E
{
	I = 0;
}

:CLV     is op=0x0A
{
	V = 0;
}

:CMP OP1     is lo=1 ... & OP1
{ 
	local op1 = OP1;
	local tmp = A - op1;
	resultFlags(tmp);
	C = (A < op1);
}

:CPX OP2     is (op=0x8 | op=0x8d | op=0x8e | op=0x8f) ... & OP2
{
	local op1 = OP2;
	local tmp = X - op1;
	resultFlags(tmp);
	C = (X < op1);
}

:DEC OP2     is (op=0xC6 | op=0xCE | op=0xD6 | op=0xDE) ... & OP2
{
	local tmp = OP2 - 1;
	OP2 = tmp;
	resultFlags(tmp);
}

:DEX     is op=0x09
{
	X = X - 1;
	resultFlags(X);
}


:EOR OP1     is (cc=1 & aaa=2) ... & OP1
{ 
	local op1 = OP1;
	A = A ^ op1;
	resultFlags(A);
}

:INC OP2     is (op=0xE6 | op=0xEE | op=0xF6 | op=0xFE) ... & OP2
{
	local tmp = OP2 + 1;
	OP2 = tmp;
	resultFlags(tmp);
}

:INX     is op=0x08
{
	X = X + 1;
	resultFlags(X);
}

:JMP ADDR16     is (op=0x7E); ADDR16
{
	goto ADDR16;
}

:JMP imm8,X     is (op=0x6E); imm8
{
	goto [*:2 X+imm8];
}

:JSR   ADDR16    is op=0x20; ADDR16
{
	*:2 (SP-1) = inst_next;
	SP=SP-2; 
	call ADDR16;
}

:LDA OP1     is (cc=1 & aaa=5) ... & OP1
{
	A = OP1;
	resultFlags(A);
}

:LDX OP3LD     is (op=0xA2 | op=0xA6 | op=0xAE | op=0xB6 | op=0xBE) ... & OP3LD
{
	X = OP3LD;
	resultFlags(X);
}

:LSR OP2     is (op=0x46 | op=0x4A | op=0x4E | op=0x56 | op=0x5E) ... & OP2
{
	local tmp = OP2;
	C = tmp & 1;
	tmp = tmp >> 1;
	OP2 = tmp;
	Z = (tmp == 0);
	N = 0;	
}

:MUL     is op=0x3D
{
        local tmpa = A;
	local tmpb = B;
	
        A = (tmpa * tmpb) >> 8;
	B = (tmpa * tmpb) & 0xFF;
}

:NOP     is op=0x01
{
       A = A;
}

:ORA  OP1    is  (cc=1 & aaa=0) ... & OP1
{
	A = A | OP1; 
	resultFlags(A);
}

:PSHA     is op=0x36
{
	*:1 (SP) = A;
	SP = SP - 1;
}

:PULA   is op=0x32
{
	SP = SP + 1;
	A = *:1 (SP);
}

:PSHB     is op=0x37
{
	*:1 (SP) = B;
	SP = SP - 1;
}

:PULB   is op=0x33
{
	SP = SP + 1;
	B = *:1 (SP);
}

:ROL OP2     is (op=0x2E | op=0x3E) ... & OP2
{
	local tmpC = C;
	local op2 = OP2;
	C = op2 >> 7;
	local result = op2 << 1;
	result = result | tmpC;
	OP2 = result;
	resultFlags(result);	
}

:ROR OP2     is (op=0x66 | op=0x6A | op=0x76) ... & OP2
{
	local tmpC = C << 7;
	local tmp = OP2;
	C = tmp & 1;
	tmp = tmp >> 1;
	tmp = tmp | tmpC;
	OP2 = tmp;
	resultFlags(tmp);	
}
:RTI      is op=0x3B
{
	popSR();
	SP = SP+1;
	
    SP = SP+1;
	tmp:2 = *:2 SP;
	SP = SP+1;
	
	return [tmp];
}

:RTS      is op=0x39
{
	SP = SP+1;
	tmp:2 = *:2 SP;
	SP = SP+1;
	
	return [tmp];
}

:SBC OP1     is (cc=1 & aaa=7) ... & OP1
{
	local op1 = OP1;
	local result = A - op1 - C;
	
	subtraction_flags1(A, op1, result);
	A = result;	
	
	# resultFlags(tmp);
	# C = ((A <= op1) * C) | (A < op1);
	# A = tmp;
}

:SEC     is op=0x0D
{
	C = 1;
}

:SEI     is op=0x0F
{
	I = 1;
}

:STA OP1     is (cc=1 & aaa=4) ... & OP1
{
	OP1 = A;
	resultFlags(A);
}

:STX OP3ST     is (op=0x86 | op=0x8E | op=0x96) ... & OP3ST
{
	OP3ST = X;
	resultFlags(X);
}


:TSX     is op=0x30
{
	X = SP;
}

:TXS     is op=0x35
{
	SP = X;
}


